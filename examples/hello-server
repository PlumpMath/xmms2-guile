;; -*- scheme-*-

;; Here is the simplest exchange you can do with an XMMS2 server. You create a
;; connection object, then use that object to connect to the server and then
;; you send the HELLO message to the server, to which the server will reply.
;;
;; The script prints the reply from the server to stdout.

(use-modules (ice-9 format)
             (rnrs bytevectors)
             (xmms2 io)
             (xmms2 messages)
             (xmms2 header))

;; You'll notice the "socat" in the unix socket name here. What this hints at
;; is the use of socat to look at the byte-stream between client and server.
;; The thing is that it is impossible to sniff unix socket connections with
;; something like wireshark. But you can insert something that provides a
;; socket to a client and forwards everything to another socket while printing
;; all the traffic that goes through that pipe. "socat" does exactly that.
;;
;; Here is how I construct such a printing connection:
;;
;;    socat -t100 -x -v \
;;          UNIX-LISTEN:/tmp/xmms-ipc-"$USER".socat,mode=700,reuseaddr \
;;          fork \
;;          UNIX-CONNECT:/tmp/xmms-ipc-"$USER"
;;
;; Where "$USER" is my user name on the system, which is why getlogin is used
;; in the expression below.
(define server (make-xmms2-connection
                (string-concatenate (list "unix:///tmp/xmms-ipc-"
                                          (getlogin)
                                          ".socat"))))
(xmms2-connect server)
(xmms2-send server (make-hello "example-hello-server"))

;; Get the response from the server:
(define response (xmms2-recv server))

;; Extract the header from the response:
(define header (car response))

;; Deconstruct header:
(format #t "~a~%" response)
(format #t "object-type: ~x~%" (header->object-type header))
(format #t "command-id: ~x~%" (header->command-id header))
(format #t "cookie: ~x~%" (header->cookie header))
(define pl (header->payload-length header))
(format #t "payload-length: ~d~%" pl)

;; The response from xmms2-recv contains a parsed version of the payload-length
;; and that should better match the payload-length field from the header.
(format #t "Payload length from header ~a payload from response list.~%"
        (if (= pl (cadr response))
            "matches"
            "does NOT match"))

;; In addition, the length of the payload byte-vector has to match that number
;; as well. If it doesn't either the server sends faulty data, data gets lost
;; in the transmission channel or we got a bug in this library.
(format #t "The length of the payload buffer ~a payload from response list.~%"
        (if (= pl (bytevector-length (caddr response)))
            "matches"
            "does NOT match"))
